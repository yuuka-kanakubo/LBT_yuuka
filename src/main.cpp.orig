///////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Linear Boltzmann Transport Model
//
//  Updated on 6/1/2017: clean up code and extract input parameters out into a input file
//
//  Run by ./LBT parameter_file input_parton_list HQ_output light_positive_output light_negative_output
//  If initHardFlag==0, no input_parton_list
//  If heavyOut==0, no HQ_output
//  If lightOut==0, no light_positive/negative_output
//
///////////////////////////////////////////////////////////////////////////////////////////////////

#include<fstream>
#include<iostream>
#include<iomanip>

#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include <math.h>
#include <vector>

using namespace std;


// declare functions for using OSU/CCNU hydro

#include<cstring>

#include "LBTConfig.h"
#include "LBTcl.h"
#include "fnc.cpp"

int main(int argc, char* argv[]){  					

    double initPT,rangePT;
    string parameterFile;
    ifstream fpList;
    ofstream outHQ,positive,negative;
    LBTConfig lbtcfg;

    if(argc<2) {
        cout<<"Please add file name for input parameter ./LBT parameter_file ..." << endl;
        exit(EXIT_FAILURE);
    }
    parameterFile = argv[1];
    lbtcfg.loadFromFile(parameterFile); // re-set parameters from input parameter file	

    if(lbtcfg.checkParameter(argc)==0) { // check whether the input parameters are all correct
        cout << "Parameter check passed" << endl;
    } else {
        cout << "Parameter check failed" << endl;
        exit(EXIT_FAILURE);
    }
	
    LBTcl lbt;

//    if(vacORmed==1) read_tables(); // initialize various tables
//
////...define derived quantities
//    temp00=temp0;		
//    dt=dtau;
//    timend=tauend;			
//    time0=tau0;	  	
////...alphas	
//    alphas=alphas0(Kalphas,temp0);
////...Debye Mass square
//    qhat0=DebyeMass2(Kqhat0,alphas,temp0);	
//	 
////...multiple scattering process
//
//
////...initialize the random number generator
//    srand(123);
//    //srand((unsigned)time(NULL));
//    NUM1=-1*rand();
//cout << "rand() " << NUM1 << endl;
////    NUM1=-33;
//
//    struct tm *local_start;
//    time_t time_start;
//    time_start=time(NULL);
//    local_start=localtime(&time_start);
//    
//    char buf1[80];
//    strftime(buf1,80,"Current Time: %Y-%m-%d %H:%M:%S",local_start);
//    cout << "the program starts at:" <<endl;
//    cout << buf1 << endl;
//
////
//////...input and output files
////    if(initHardFlag==1) { // initialize hard partons within LBT
////        if(heavyOut==1 && lightOut==1) { // both heavy and light output
////            outHQ.open(argv[2]);
////            positive.open(argv[3]);
////            negative.open(argv[4]);
////        } else if(heavyOut==1) { // only heavy output
////            outHQ.open(argv[2]);
////        } else if(lightOut==1) { // only light output
////            positive.open(argv[2]);
////            negative.open(argv[3]);
////        } else {
////            cout << "Warning: no output file will be generated!" << endl;
////        }
////    } else { // need initial parton list 
////        fpList.open(argv[2]);
////        if(heavyOut==1 && lightOut==1) { // both heavy and light output
////            outHQ.open(argv[3]);
////            positive.open(argv[4]);
////            negative.open(argv[5]);
////        } else if(heavyOut==1) { // only heavy output
////            outHQ.open(argv[3]);
////        } else if(lightOut==1) { // only light output
////            positive.open(argv[3]);
////            negative.open(argv[4]);
////        } else {
////            cout << "Warning: no output file will be generated!" << endl;
////        }
////    }
////
//////...Begin event + time loop for parton evolution	  
////
////    int numEvent = 0;	   
////
////    for(int n=1; ; ++n) {
////
////        if(initHardFlag==1) {  // initialize within LBT
////            if(numEvent>=ncall) break;
////        } else if(initHardFlag==2) { // initialize by reading particle list
////            if(numEvent>=ncall) break;
////            if(fpList.eof()) break;
////        } // no other possibility, already checked by checkParameter function
////
//////        eGluon=0.0;       
//////        nGluon=0.0;
////
////        jetClean();
////
//////...initilization of jet parton
////
////        if(initHardFlag==1) {  // initialize within LBT
////            jetInitialize(numInitXY); // initialize jet partons
////        } else { // initialize by reading particle list
////            int dummyInt;
////            if(fpList.eof()) break;
////            fpList >> dummyInt >> nj;
////
////            // read particle information from file, may move to a function outside in future
////            double EiTot=0.0;
////            for(int i=1; i<=nj; i=i+1) {
////
////                fpList >> dummyInt >> KATT1[i] >> P[1][i] >> P[2][i] >> P[3][i] >> P[0][i] >> Vfrozen[1][i] >> Vfrozen[2][i] >> Vfrozen[3][i] >> Vfrozen[0][i];
////
////		//Propagating initial partons till its formation location in transverse
////		//==============================
////                Vfrozen[1][i]=Vfrozen[1][i]+P[1][i]/P[0][i]*Vfrozen[0][i];
////                Vfrozen[2][i]=Vfrozen[2][i]+P[2][i]/P[0][i]*Vfrozen[0][i];
////                Vfrozen[3][i]=0.0;
////
////                V[1][i]=Vfrozen[1][i];
////                V[2][i]=Vfrozen[2][i];
////                V[3][i]=Vfrozen[3][i];
////                       
////                V[0][i]=-log(1.0-ran0(&NUM1));
////  
////                // adjust momentum to fit energy and mass
////
////		if(abs(KATT1[i])==1||abs(KATT1[i])==2||abs(KATT1[i])==3||abs(KATT1[i])==21)
////		{
////			P[4][i]=0.0;
////			P[0][i]=sqrt(P[1][i]*P[1][i]+P[2][i]*P[2][i]+P[3][i]*P[3][i]+P[4][i]*P[4][i]);
////			P[5][i]=sqrt(P[1][i]*P[1][i]+P[2][i]*P[2][i]);//transverse momentum
////			WT[i]=1.0;
////		}
////
////                EiTot=EiTot+P[0][i];//Counting total energy in initial partons.
////
////                for(int j=0;j<=3;j++) Prad[j][i]=P[j][i];
////  
////                Tfrozen[i]=0.0;
////                vcfrozen[1][i]=0.0;
////                vcfrozen[2][i]=0.0;
////                vcfrozen[3][i]=0.0;
////            }
////
//////            cout<<"EiTot: "<<EiTot<<endl;
////
////            // reset position information if necessary
////            if(flagJetX==1) setJetX(numInitXY);
////
////        }//Loop for reading initial partons. 
////
////        np=nj;//Number of initial partons.
////        
////	//...end initilization of jet parton
////	//...time evolution in LBT if in medium
////
////        if(vacORmed==1) {//vacuum or medium. 1: medium, 0: vacuum
////		
////            for(double ti=time0+dt;ti<=timend+epsilon;ti=ti+dt) {
////
////		    LBTcl lbt_;
////		    lbt_.LBTstep(n,ti,np);//n: event number,  ti: time in timestep
////
////            }
////        }
////
////	//...end of time evolution in LBT
////
////        numEvent=numEvent+1;		
////
//////...write outputs
////
////        double EfTot=0.0; // check energy conservation
////
////        int ip=0;
////        int iHQ=0;
////        for(int i=1;i<=np;i++) {
////            if(P[0][i] < cutOut && abs(KATT1[i])!=4) ip+=1;
////            if(abs(KATT1[i])==4) iHQ+=1;
////            EfTot=EfTot+P[0][i];
////        }	
////        int nnn=np-ip-iHQ;// np: # of input partons, 
////        int ip0=0;
////        for(int i=2;i<=np;i++) {
////            if(P0[0][i] < cutOut) ip0+=1;
////            EfTot=EfTot-P0[0][i];
////        }	
////        int nnn0=np-ip0;
////
//////        cout<<"EfTot: "<<EfTot<<endl;
////
////        if(outFormat==1){
////
////            if(heavyOut==1) outHQ << n << "    " << iHQ << endl;
////            if(lightOut==1) positive << n << "    " << nnn << endl;
////            for(int i=1;i<=np;i++) { // if only want to write out leading partons, change np->nj
////                if(P[0][i] < cutOut && abs(KATT1[i])!=4) continue; // throw away light partons below cut
////                if(abs(KATT1[i])==4){ // write out heavy quark
////                    if(heavyOut==1 && KATT1[i]==4) outHQ << i << "    "  << "5" << "    " << P[1][i] << "    " << P[2][i] << "    " << P[3][i] << "    " << P[0][i] << "    " << Vfrozen[1][i] << "    " << Vfrozen[2][i] << "    " << Vfrozen[3][i] << "    " << Vfrozen[0][i] << endl;
////                    if(heavyOut==1 && KATT1[i]==-4) outHQ << i << "    "  << "-5" << "    " << P[1][i] << "    " << P[2][i] << "    " << P[3][i] << "    " << P[0][i] << "    " << Vfrozen[1][i] << "    " << Vfrozen[2][i] << "    " << Vfrozen[3][i] << "    " << Vfrozen[0][i] << endl;
////                } else { // write out light parton
////                    if(lightOut==1) positive << i << "    " << KATT1[i] <<  "    " << P[1][i] << "    " << P[2][i] << "    " << P[3][i] << "    " << P[0][i] << "    " << Vfrozen[1][i] << "    " << Vfrozen[2][i] << "    " << Vfrozen[3][i] << "    " << Vfrozen[0][i] << "    " << CAT[i] << endl;
////                }
////            }	
////
////            if(lightOut==1) negative << n << "    " << nnn0-1 << endl;
////            for(int i=2;i<=np;i++) {
////                if(P0[0][i] < cutOut) continue;
////                if(lightOut==1) negative << i << "   " << KATT10[i] << "    " << P0[1][i] << "    " << P0[2][i] << "    " << P0[3][i] << "    " << P0[0][i] << "    " << Vfrozen0[1][i] << "    " << Vfrozen0[2][i] << "    " << Vfrozen0[3][i] << "    " << Vfrozen0[0][i] << endl;
////            }	
////
////        } else if(outFormat==2) { // for JETSCAPE patch code
////
////            if(heavyOut==1) outHQ << n << "    " << iHQ << "    " << initPT << "    " << rangePT << endl;
////            if(lightOut==1) positive << n << "    " << nnn << "    " << initPT << "    " << rangePT << endl;
////            for(int i=1;i<=np;i++) { // if only want to write out leading partons, change np->nj
////                if(P[0][i] < cutOut && abs(KATT1[i])!=4) continue; // throw away light partons below cut
////                if(abs(KATT1[i])==4){ // write out heavy quark
////                    if(heavyOut==1) outHQ << i << "    " << KATT1[i] <<  "    " << P[1][i] << "    " << P[2][i] << "    " << P[3][i] << "    " << P[0][i] << "    " << P[4][i] << "    " << Vfrozen[1][i] << "    " << Vfrozen[2][i] << "    " << Vfrozen[3][i] << "    " << Vfrozen[0][i] << endl;
////                } else { // write out light parton
////                    if(lightOut==1) positive << i << "    " << KATT1[i] <<  "    " << P[1][i] << "    " << P[2][i] << "    " << P[3][i] << "    " << P[0][i] << "    " << P[4][i] << "    " << Vfrozen[1][i] << "    " << Vfrozen[2][i] << "    " << Vfrozen[3][i] << "    " << Vfrozen[0][i] << endl;
////                }
////            }	
////
////            if(lightOut==1) negative << n << "    " << nnn0-1 << "    " << initPT << "    " << rangePT << endl;
////            for(int i=2;i<=np;i++) {
////                if(P0[0][i] < cutOut) continue;
////                if(lightOut==1) negative << i << "   " << KATT10[i] << "    " << P0[1][i] << "    " << P0[2][i] << "    " << P0[3][i] << "    " << P0[0][i] << "    " << P0[4][i] << "    " << Vfrozen0[1][i] << "    " << Vfrozen0[2][i] << "    " << Vfrozen0[3][i] << "    " << Vfrozen0[0][i] << endl;
////            }	
////
////        }
////
//////...end of output
////
////        int print=n%nprint;
////
////	if(print==0) {
////            cout << "  " << endl;
////            cout<< "n" << "  " << "np" << endl;      
////            cout << n << "  " << np << endl;
////	}
////
////    } //for(int n=1;n<=ncall;n++)
////
//////...end of event loop (e.g. ncall)
////
////    if(lightOut==1){ 
////        positive.close();
////        negative.close();
////    }
////    if(heavyOut==1){
////        outHQ.close();
////    }
//// 
////
//////...check system time, computational cost, etc.
////
////    struct tm *local_end;
////    time_t time_end;
////    time_end=time(NULL);
////    local_end=localtime(&time_end);
////    
////    char buf2[80];
////    strftime(buf2,80,"Current Time: %Y-%m-%d %H:%M:%S",local_end);
////    cout << "the program ends at:" << endl;
////    cout << buf2 << endl;
////    
////    unsigned cost,nh,nm,ns;
////    cost=difftime(time_end,time_start);
////    
////    nh=cost/3600;
////    nm=(cost%3600)/60;
////    ns=(cost%3600)%60;
////    
////    cout << "the program costs:" << endl;
////    cout << cost << "s:" << " " << nh << "h" << " " << nm << "m" << " " << ns << "s" << endl;	
////    cout << "counth100" << " " << counth100 <<endl;
    
    return 0;
}



